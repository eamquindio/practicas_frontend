version: 2

jobs:
  build_and_test:
        working_directory: ~/project
        docker:
            - image: circleci/node:10
        steps:
            # Checkout the code from the branch into the working_directory
            - checkout
            # Log the current branch
            - run:
                name: Show current branch
                command: echo ${CIRCLE_BRANCH}
            # Restore local dependencies from cache
            - restore_cache:
                keys:
                - v1-dependencies-{{ checksum "package.json" }}
                - v1-dependencies-
            # Install project dependencies
            - run:
                name: Install local dependencies
                command: npm install
            # Cache local dependencies if they don't exist
            - save_cache:
                key: v1-dependencies-{{ checksum "package.json" }}
                paths:
                    - node_modules
            # Lint the source code
            - run:
                name: Linting
                command: npm run lint
            # Test the source code
            #- run:
             #   name: Testing
              #  command: npm run test
            # Build project with different configuration based on
            # the current branch
            - run:
                name: Building
                command: npm run build

  docker_push:
    # Build app container and push it to the GCR registry
    # Note: we want to build and push an image with tags based on both
    # the Git commit hash AND the branch name. This way, we can refer to
    # images by commit (which is immutable) or branch name (which
    # dynamically tracks the latest build for each branch).
    docker:
      - image: bayesimpact/circleci
    working_directory: ~/repo
    steps:
      - checkout
      - setup_remote_docker
      - run:
          name: Authenticate with GCR
          command: |
            echo "${GCR_DOCKER_REGISTRY_PASSWORD}" | docker login -u _json_key --password-stdin https://gcr.io
      - run:
          name: Build app image
          command: |
            docker build --rm=false \
            -t gcr.io/${GCR_PROJECT}/myapp:${CIRCLE_SHA1} \
            -t gcr.io/${GCR_PROJECT}/myapp:${CIRCLE_BRANCH} \
            -f ./Dockerfile .
      - run:
          name: Push app image
          command: |
            docker push gcr.io/${GCR_PROJECT}/myapp:${CIRCLE_SHA1}
            docker push gcr.io/${GCR_PROJECT}/myapp:${CIRCLE_BRANCH}
  kubernetes_deploy:
    # Update the existing Kubernetes deployment to point to the new image
    docker:
      - image: google/cloud-sdk:alpine
    working_directory: ~/repo
    steps:
      - run:
          name: Deploy the current commit on this branch to the GKE cluster
          command: |
            gcloud components install kubectl
            echo "${GKE_CD_SERVICE_ACCOUNT_KEY}" > .key.json
            gcloud auth activate-service-account --key-file .key.json
            gcloud config set compute/zone "${GKE_ZONE}"
            gcloud config set project "${GKE_PROJECT}"
            gcloud container clusters get-credentials "${GKE_CLUSTER}" --zone "${GKE_ZONE}"
            kubectl set image deployment/${CIRCLE_BRANCH}-app ${CIRCLE_BRANCH}-app=gcr.io/${GCR_PROJECT}/myapp:${CIRCLE_SHA1}
workflows:
  version: 2
  build_and_test:
    jobs:
      # note: skip tests on prod and staging branches.
      # This assumes your workflow ensures that tests pass in the dev branch
      # before the code is promoted to staging.
      - build_and_test:
  deploy:
    jobs:
      # note: this step only runs on prod and staging branches.
      - docker_push:
          filters:
            branches:
              only:
                - develop
                - master
          requires:
            - build_and_test
      - kubernetes_deploy:
          filters:
            branches:
              only:
                - develop
                - master
          requires:
            - docker_push